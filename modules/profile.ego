#!/usr/bin/python3
import argparse
import json
import os
import sys

import portage

from ego import EgoModule
from ego_helpers import Color, depluralize
from ego_profile import getProfileCatalogAndTree, ProfileType

class MultiChoicesAction(argparse.Action):

	def __init__(self, *args, **kwargs):
		self.multi_choices = kwargs.pop('choices')
		return super().__init__(*args, **kwargs)

	def __call__(self, parser, namespace, values, option_string=None):
		for value in values:
			if value not in self.multi_choices:
				raise argparse.ArgumentError(self, "invalid choice: %r (choose from %s)" % (
					value, ', '.join([repr(c) for c in self.multi_choices])))
		setattr(namespace, self.dest, values)

class Module(EgoModule):

	def add_arguments(self, parser):

		# specify "mix-in" as alternate spelling for "mix-ins":

		valid_profile_types = [ str(x) for x in ProfileType.valid() ]
		subparsers = parser.add_subparsers(title='actions', dest='action')

		show_parser = subparsers.add_parser('show', help="Print your profiles")
		show_parser.set_defaults(handler=self.handle_show_action)

		show_json_parser = subparsers.add_parser('show-json', help="Print your profiles in JSON format")
		show_json_parser.set_defaults(handler=self.handle_show_json_action)

		get_parser = subparsers.add_parser('get', help="Print the value of a given profile")
		get_parser.add_argument('profile', choices=valid_profile_types)
		get_parser.set_defaults(handler=self.handle_get_action)

		list_parser = subparsers.add_parser('list', help="List given profiles (or all by default)")
		list_parser.add_argument('profiles', nargs='*', choices=valid_profile_types, action=MultiChoicesAction, help=(
			"Profiles to show: %s" % ', '.join(valid_profile_types)
		))
		list_parser.set_defaults(handler=self.handle_list_action)

		update_parser = subparsers.add_parser('update', help="Update your profiles (/etc/portage/make.profile/parent)")
		update_parser.set_defaults(handler=self.handle_update_action)

		single_profile_parsers = [
			subparsers.add_parser('arch', help="Change your arch profile"),
			subparsers.add_parser('build', help="Change your build profile"),
			subparsers.add_parser('subarch', help="Change your subarch profile"),
			subparsers.add_parser('flavor', help="Change your flavor profile"),
		]
		for subparser in single_profile_parsers:
			subparser.add_argument('new_value')
			subparser.set_defaults(handler=self.handle_single_profile_actions)

		mixins_parser = subparsers.add_parser('mix-ins', aliases=['mix-in'], help="Change your mix-ins profile")
		mixins_parser.add_argument('mixins', nargs='*')
		mixins_parser.set_defaults(handler=self.handle_mix_ins_action)

	def header(self, info):
		self.log("\n=== " + Color.BOLD + Color.GREEN + str(info) + Color.END + ": ===\n")

	def python_info(self):
		self.header("Python kit")
		self.log("%s%12s%s: %s%s%s" % (
			Color.BOLD, "branch", Color.END, Color.CYAN, self.get_configured_kit("python-kit"), Color.END))

	def short_list(self):
		self.header("Enabled Profiles")
		for key in [ ProfileType.ARCH, ProfileType.BUILD, ProfileType.SUBARCH, ProfileType.FLAVOR, ProfileType.MIX_IN ]:
			all_enabled = list(self.tree.get_children(key))
			if len(all_enabled) == 0:
				self.log("%s%12s%s: (not set)" % (Color.BOLD, key, Color.END))
			else:
				for item in all_enabled:
					self.log("%s%12s%s: %s%s%s" % (Color.BOLD, key, Color.END, Color.CYAN, item.name, Color.END))
		self.log("")

	def short_JSON(self):
		outdict = {}
		for p_type in [ProfileType.ARCH, ProfileType.BUILD, ProfileType.SUBARCH, ProfileType.FLAVOR, ProfileType.MIX_IN]:
			key = str(p_type)
			outdict[key] = []
			for item in self.tree.get_children(p_type):
				out = {}
				out["shortname"] = item.name
				#if item.path is not None:
					# TODO: support path
				#	out["path"] = item.path
				outdict[key].append(out)
		return outdict

	def handle_show_action(self, **options):
		self.short_list()
		self.python_info()

		for specifier in self.tree.get_children([ProfileType.FLAVOR, ProfileType.MIX_IN]):

			for list_type in [ ProfileType.FLAVOR, ProfileType.MIX_IN ]:
				inherited_things = list(self.tree.recursively_get_children(list_type, specifier=specifier))

				if not len(inherited_things):
					continue

				self.header("All inherited %s from %s %s" % (str(list_type), specifier.name, str(specifier.classify())))

				for inherited_spec in inherited_things:
					parent = self.tree.get_parent(inherited_spec)
					parent_name = parent.name if parent else "master profile"
					parent_type = depluralize(str(parent.classify())) if parent else "(None)"
					self.log("      %s%26s%s (from %s %s)" % (Color.CYAN, inherited_spec.name, Color.END, parent_name, parent_type))
		self.log("")

	def handle_update_action(self, **options):
		try:
			self.tree.write()
		except PermissionError:
			self.fatal("You do not have permission to update profiles.")

	def handle_show_json_action(self, **options):
		self.log(json.dumps(self.short_JSON(), indent=4))

	def handle_get_action(self, **options):
		self.log(' '.join(p.name for p in self.tree.get_children(ProfileType.from_string(options['profile']))))

	def handle_list_action(self, **options):

		# Time to list all available profile settings.
		profiles = options['profiles']

		for key in [ ProfileType.ARCH, ProfileType.BUILD, ProfileType.SUBARCH, ProfileType.FLAVOR, ProfileType.MIX_IN ]:
			if profiles and str(key) not in profiles:
				continue

			# active_keys: Names of active (currently enabled explicitly by user) profile keys
			# of this type (ie. flavor, etc.). These active ones will get highlighted differently.

			active_keys = [ x.name for x in self.tree.get_children(key) ]
			recursively_active_keys = set( x.name for x in self.tree.recursively_get_children(key) )
			available_keys = sorted(list(self.catalog.list(key)))
			self.header(key)

			# We handle our own output formatting/spacing/newlines. These vars are used for this.
			# lpos - column position; maxpos - when to wrap; count - item count.

			lpos = 4
			maxpos = 60
			count = 0

			# write each item out -- when we cross maxpos characters, add a newline and indent:
			self.echo(" " * lpos)
			if not len(available_keys):
				self.echo("None available")
				continue
			for x in available_keys:
				if lpos > maxpos:
					self.echo("\n")
					lpos = 4
					self.echo(" " * lpos)
				if x in active_keys:
					# make it stand out if it explicitly enabled:
					outx = Color.BOLD + Color.CYAN + x + "*" + Color.END
					if key in ["arch", "build"]:
						# parens to mark as read-only -- USE style. Not really read-only but should
						# not generally be changed by user.
						outx = "(" + outx + ")"
				elif x in recursively_active_keys:
					# highlight if enabled through inheritance:
					outx = Color.DARKCYAN + x + Color.END
				else:
					outx = x
				count += 1
				if count == 1 or lpos == 4:
					self.echo(outx)
					lpos += len(x)
				else:
					self.echo(", " + outx)
					lpos += len(x) + 2
			self.log("")
		self.log("")

	def handle_single_profile_actions(self, **options):
		action = options['action']
		newset = options['new_value']
		print(action, newset)
		profile_type = ProfileType.from_string(action)
		if profile_type == None:
			self.fatal("Unknown profile type: %s" % action)
		elif profile_type == ProfileType.OTHER:
			self.fatal("Profile type of 'other' not valid.")

		available_shortnames = set(self.catalog.list(profile_type))
		current_setting = list(self.tree.get_children())[0]

		if profile_type in [ ProfileType.BUILD, ProfileType.ARCH ]:
			if newset in available_shortnames and len(action) > 0:
				self.warning("%s already set to %s -- typically, user should not change this." % (
					action, current_setting.name))

		if newset not in available_shortnames:
			self.fatal("%s %s not available. Can't set." % (action, newset))
		self.writeout = True

		self.tree.replace_entry(profile_type, "core-kit:" + self.catalog.find_path(profile_type, newset))

		self.short_list()
		self.log(">>> Set %s to %s." % (action, newset))

	def handle_mix_ins_action(self, **options):
		mixins = options['mixins']

		adds = set()
		subs = set()
		for mixin in mixins:
			if mixin[0] == "-":
				subs.add(mixin[1:])
			elif mixin[0] == "+":
				adds.add(mixin[1:])
			else:
				adds.add(mixin)

		valids = list(self.catalog.list(ProfileType.MIX_IN))

		for mixin in adds.union(subs):
			if mixin not in valids:
				self.fatal("Error: %s is not a valid mix-in." % mixin)

		# remove "-" arguments.
		removed = set()
		added = set()

		# for mix_in in enabled-mix-ins:

		enabled_mix_ins = list(self.tree.get_children([ProfileType.MIX_IN]))
		for mix_in in enabled_mix_ins:
			if mix_in.name in subs:
				removed.add(mix_in.name)
				self.tree.remove_name(ProfileType.MIX_IN, mix_in.name)
				self.writeout = True

		available_mix_in_shortnames = set(self.catalog.list(ProfileType.MIX_IN))
		not_added = adds - available_mix_in_shortnames

		for shortname in adds & available_mix_in_shortnames:
			self.tree.append_mixin("gentoo:" + self.catalog.find_path(ProfileType.MIX_IN, shortname))
			self.writeout = True

		# Do all output here -- our shortList() will reflect the mix-in changes made above. Then put informational messages
		# underneath for readability:

		self.short_list()
		for mixin in subs.difference(removed):
			self.warning("Mix-in %s not found, not removing." % mixin)
		for mixin in not_added:
			self.warning("Mix-in %s already active, not adding." % mixin)
		for mixin in removed:
			self.log(">>> Removed %s mix-in." % mixin)
		for mixin in added:
			self.log(">>> Added %s mix-in." % mixin)

	def handle(self, **options):
		portdir = portage.settings.repositories.mainRepoLocation()

		upgrade_to_core_kit = False

		self.catalog, self.tree = getProfileCatalogAndTree(portdir)

		# If the profile needs to be written out for any reason, to either update it or fix it, writeout will be set to
		# true.

		self.writeout = upgrade_to_core_kit

		handler = options.pop('handler', self.handle_show_action)
		handler(**options)

		for profile_type in ProfileType.single():
			settings = list(self.tree.get_children(profile_type))
			if len(settings) > 1:
				for setting in settings[1:]:
					self.warning("Extra profile of type '%s' defined: '%s'. Will be removed." % (str(profile_type), setting.name))
				self.writeout = True
			elif len(settings) == 0:
				self.warning("No %s defined. Please set." % str(profile_type))

		if self.writeout:
			if upgrade_to_core_kit:
				self.warning("Upgrading gentoo repository references to core-kit.")
			try:
				self.tree.write()
			except PermissionError:
				self.fatal("You do not have permission to update profiles.")

	def __call__(self, *args):
		# Little trick to force end of arguments when using mix-ins command to
		# prevent argparse from considering "-foo" as an argument.
		if len(args) and '--' not in args and args[0] in ['mix-in', 'mix-ins']:
			args = (args[0], '--') + args[1:]
		super().__call__(*args)

# vim: ts=4 noexpandtab sw=4
