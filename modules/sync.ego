#!/usr/bin/python3

import os
import pwd
import re
import sys

from cmdtools import run
from ego.module import EgoModule
from ego.output import Color, Output
from git_helper import GitHelper


class Module(EgoModule):

	hex_re = re.compile('[0-9a-fA-F]+')

	@property
	def root(self):
		if not hasattr(self, '_root'):
			root = self.config.meta_repo_root
			if not os.path.exists(os.path.dirname(root)):
				os.makedirs(os.path.dirname(root))
			self._root = root
		return self._root

	def add_arguments(self, parser):
		parser.add_argument('--kits-only', action='store_true', help="Do not sync meta-repo, only kits.")

	def sync_kit(self, kit_name, branch=None):
		if branch is None:
			# use default
			branch = self.config.kit_info["kit_settings"][kit_name]["default"]
		if branch is None:
			Output.fatal("Fatal: branch cannot be None.")
		if branch == self.config.kit_info["kit_settings"][kit_name]["default"]:
			Output.log(Color.purple("Syncing %s branch %s" % (kit_name, branch)))
		else:
			# highlight non-default branches in green for convenience
			Output.log(Color.purple("Syncing %s branch " % kit_name) + Color.green(branch) + Color.purple(" (non-default)"))
		kit_path = os.path.join(self.config.kit_root, kit_name)
		kit = GitHelper(self, kit_path)
		if not kit.isGitRepo():
			try:
				os.rmdir(kit.root)
			except OSError:
				pass
		if not kit.exists():
			retval = kit.clone(self.config.sync_base_url.format(repo=kit_name), branch,
			                   depth=self.config.kits_depth if self.config.kits_depth != 0 else None)
			if retval != 0:
				Output.fatal("Could not clone kit '%s' into '%s'." % (kit_name, kit_path))

		if not kit.localBranchExists(branch):
			kit.fetchRemote(branch)
		kit.checkout(branch)
		kit.reset(options=["--hard"])
		kit.clean(options=["-fd"])
		kit.pull(options=["-f", "--no-commit"])

		# do sync
		sha1 = kit.commitID
		desired_sha1 = self.config.kit_sha1[kit_name][branch]
		success = False

		def sha1_check(my_sha1, desired_sha1):
			Output.debug((my_sha1, desired_sha1))
			if not self.hex_re.match(my_sha1):
				Output.fatal("Fatal: kit CommitID not a SHA1: %s" % my_sha1)
			if not self.hex_re.match(desired_sha1):
				Output.fatal("Fatal: kit-sha1.json value not a SHA1: %s" % desired_sha1)

		sha1_check(sha1, desired_sha1)

		if sha1 == desired_sha1:
			success = True
		else:
			kit.fetchRemote(branch)
			sha1 = kit.commitID
			sha1_check(sha1, desired_sha1)
			if sha1 != desired_sha1:
				success = kit.checkout(desired_sha1)
		return success

	def update_repos_conf(self):

		if os.path.islink(self.config.repos_conf_path):
			try:
				os.unlink(self.config.repos_conf_path)
				Output.echo(Color.darkcyan("Upgrading %s symlink to directory..." % self.config.repos_conf_path))
			except PermissionError:
				Output.warning("Unable to convert %s to directory; please do so manually." %
				               self.config.repos_conf_path)

		# generate new repos.conf entries:

		if not os.path.exists(self.config.repos_conf_path):
			os.makedirs(self.config.repos_conf_path)
		config_files = set(os.listdir(self.config.repos_conf_path))
		updated_config_files = set()
		for kit_name in self.config.kit_info["kit_order"]:
			repo_conf_path = os.path.join(self.config.repos_conf_path, "ego-" + kit_name)
			kit_path= os.path.join(self.config.kit_root, kit_name)
			if kit_name == "nokit":
				kit_priority = -500
			else:
				kit_priority = 1
			with open(repo_conf_path, "w") as f:
				f.write("""[%s]
location = %s
auto-sync = no
priority = %s	
				""" % ( kit_name, kit_path, kit_priority))
			updated_config_files.add("ego-" + kit_name)

		# clean up any repos.conf entries that begin with "ego-" that are stale:

		for config_file in config_files - updated_config_files:
			if config_file.startswith("ego-"):
				config_file_path = os.path.join(self.config.repos_conf_path, config_file)
				try:
					os.unlink(config_file_path)
				except PermissionError:
					Output.warning("Unable to remove stale repos.conf file: %s. Please remove manually." %
					               config_file_path)

	def sync_meta_repo(self, **options):
		pwnam = pwd.getpwnam(self.config.sync_user)
		uid = pwnam.pw_uid
		gid = pwnam.pw_gid
		if "HOME" in os.environ:
			# git will look here for various things
			del os.environ["HOME"]
		if not os.path.exists(self.root):
			try:
				os.mkdir(self.root)
			except PermissionError:
				Output.fatal(
					"You don't have enough privileges. You should probably run this command as root."
				)
		stat_info = os.stat(self.root)
		if stat_info.st_uid != uid and self.config.sync_user != "root":
			try:
				run("chown -R %s:%s %s" % (uid, gid, self.root), quiet=True)
			except PermissionError:
				Output.fatal(
					"You don't have enough privileges. You should probably run this command as root."
				)
		# We need to fork here in order to sync as sync_user and then switch back to root
		pid = os.fork()
		if pid == 0:
			# in child process.
			os.chdir('/tmp')  # Make sure we are not in /root or other user-forbidden directory
			try:
				os.setgid(gid)
				os.setuid(uid)
			except PermissionError:
				Output.fatal(
					"You don't have enough privileges. You should probably run this command as root."
				)
			if not options['kits_only']:
				repo = GitHelper(self, self.root)
				Output.log(Color.green("Syncing meta-repo"))
				if repo.isGitRepo():
					repo.fetchRemote("master", options=["--no-recurse-submodules"])
					repo.checkout("master")
					repo.reset(options=["--hard"])
					repo.clean(options=["-fd"])
					retval = repo.pull(options=["--no-commit", "-f", "--no-recurse-submodules"])
					if retval != 0:
						Output.fatal("There was an error syncing meta-repo.")
				else:
					retval = repo.clone(
						self.config.sync_base_url.format(repo="meta-repo"), self.config.meta_repo_branch)
					if retval != 0:
						Output.fatal("Could not clone meta-repo into '%s'." % (self.root,))
			fails = []
			for kt in self.config.kit_info["kit_order"]:
				branch = None
				if "kits" in self.config.settings:
					if kt in self.config.settings["kits"]:
						branch = self.config.settings["kits"][kt]

				# Let's now check to make sure that the kit specified in settings is a valid kit, still present in
				# metadata. If not, we should inform the user and fall back to the default kit.

				if branch is not None:
					if branch not in self.config.kit_sha1[kt]:
						# We are not recording a sha1 -- this is not an active kit
						Output.warning("Kit %s branch %s specified in ego.conf is not currently active; using default kit instead." % (kt, branch))
						branch = None

				success = self.sync_kit(kt, branch=branch)
				if not success:
					fails.append((kt, branch))
			if len(fails):
				for kt, branch in fails:
					Output.error("There was an error syncing %s." % kt)
			# these exit commands get run by the child process
				sys.exit(1)
			sys.exit(0)
		# Forked process terminated here - now we are back in the parent:
		if os.waitpid(pid, 0)[1] > 0:
			return False
		Output.log(Color.green("Sync successful and kits in alignment! :)"))
		Output.log(Color.darkcyan("Updating profiles..."))
		Output.log(Color.darkcyan("Updating repos.conf..."))
		self.update_repos_conf()
		try:
			EgoModule.run_ego_module('profile', self.config, ['update'])
		except PermissionError:
			Output.error("Could not update ego profiles automatically due to permissions (code in /root, most likely.)")
			Output.error("Please run epro update manually as root.")
		return True

	def handle(self, **options):
		self.sync_meta_repo(**options)

# vim: ts=4 sw=4 noet
