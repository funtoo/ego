#!/usr/bin/python3

import os
import pwd
import re
import sys
from ego import EgoModule
from ego_helpers import color, run_ego_module
from git_helper import GitHelper

class Module(EgoModule):

	hex_re = re.compile('[0-9a-fA-F]+')

	@property
	def root(self):
		if not hasattr(self, '_root'):
			root = self.config.meta_repo_root
			if not os.path.exists(os.path.dirname(root)):
				os.makedirs(os.path.dirname(root))
			self._root = root
		return self._root

	def add_arguments(self, parser):
		parser.add_argument('--kits-only', action='store_true', help="Do not sync meta-repo, only kits.")
		parser.add_argument('--status', action='store_true', help="Display selected kit branches.")

	def sync_kit(self, kit_name, branch=None):
		if branch is None:
			# use default
			branch = self.kit_info["kit_settings"][kit_name]["default"]
		if branch is None:

			self.fatal("Fatal: branch cannot be None.")
		if branch == self.kit_info["kit_settings"][kit_name]["default"]:
			self.log(color.purple("Syncing %s branch %s" % (kit_name, branch)))
		else:
			# highlight non-default branches in green for convenience
			self.log(color.purple("Syncing %s branch " % kit_name) + color.green(branch) + color.purple(" (non-default)"))
		kit_path = os.path.join(self.config.kit_root, kit_name)
		kit = GitHelper(self, kit_path)
		if not kit.isGitRepo():
			try:
				os.rmdir(kit.root)
			except OSError:
				pass
		if not kit.exists():
			kit.shallowClone(self.config.sync_base_repo % kit_name, branch)

		if not kit.localBranchExists(branch):
			kit.fetchRemote(branch)
		kit.checkout(branch)
		kit.reset(options=["--hard"])
		kit.clean(options=["-fd"])
		kit.pull(options=["-f", "--no-commit"])

		# do sync
		sha1 = kit.commitID
		desired_sha1 = self.kit_sha1[kit_name][branch]
		success = False

		def sha1_check(sha1, desired_sha1):
			self.debug((sha1, desired_sha1))
			if not self.hex_re.match(sha1):
				self.fatal("Fatal: kit CommitID not a SHA1: %s" % sha1)
			if not self.hex_re.match(desired_sha1):
				self.fatal("Fatal: kit-sha1.json value not a SHA1: %s" % desired_sha1)

		sha1_check(sha1, desired_sha1)

		if sha1 == desired_sha1:
			success = True
		else:
			kit.fetchRemote(branch)
			sha1 = kit.commitID
			sha1_check(sha1, desired_sha1)
			if sha1 != desired_sha1:
				success = kit.checkout(desired_sha1)
		return success

	def sync_meta_repo(self, **options):
		pwnam = pwd.getpwnam(self.config.sync_user)
		uid = pwnam.pw_uid
		gid = pwnam.pw_gid
		if "HOME" in os.environ:
			# git will look here for various things
			del os.environ["HOME"]
		if not os.path.exists(self.root):
			try:
				os.mkdir(self.root)
			except PermissionError:
				self.fatal(
					"You don't have enough privileges. You should probably run this command as root."
				)
		stat_info = os.stat(self.root)
		if stat_info.st_uid != uid and self.config.sync_user != "root":
			try:
				self.run("chown -R %s:%s %s" % (uid, gid, self.root), quiet=True)
			except PermissionError:
				self.fatal(
					"You don't have enough privileges. You should probably run this command as root."
				)
		# We need to fork here in order to sync as sync_user and then switch back to root
		pid = os.fork()
		if pid == 0:
			try:
				os.setgid(gid)
				os.setuid(uid)
			except PermissionError:
				self.fatal(
					"You don't have enough privileges. You should probably run this command as root."
				)
			if not options['kits_only']:
				repo = GitHelper(self, self.root)
				self.log(color.green("Syncing meta-repo"))
				if repo.isGitRepo():
					retval = repo.fetchRemote("master")
					retval = repo.pull(options=["--no-commit", "-f", "--no-recurse-submodules"])
					if retval != 0:
						self.fatal("There was an error syncing meta-repo.")
				else:
					repo.shallowClone(self.config.sync_base_repo % "meta_repo", self.config.meta_repo_branch)
			fails = []
			for kt in self.kit_info["kit_order"]:
				branch = None
				if "kits" in self.config.settings:
					if kt in self.config.settings["kits"]:
						branch = self.config.settings["kits"][kt]
				success = self.sync_kit(kt, branch=branch)
				if not success:
					fails.append((kt, branch))
			if len(fails):
				for kt, branch in fails:
					self.error("There was an error syncing %s." % kt)
				sys.exit(1)
			sys.exit(0)
		# Forked process terminated here
		if os.waitpid(pid, 0)[1] > 0:
			return False
		self.log(color.green("Sync successful and kits in alignment! :)"))
		self.log(color.green("Updating profiles..."))
		try:
			run_ego_module(self.install_path, 'profile', self.config, ['update'])
		except PermissionError:
			self.error("Could not update ego profiles automatically due to permissions (code in /root, most likely.)")
			self.error("Please run epro update manually as root.")
		return True

	def meta_repo_info(self, **options):
		"""
		This implements 'ego sync status' and is just a starting point. It currently displays the ego.conf-defined
		or default repo, but not the actual git repo that is selected on disk. So it should be a lot more sophisticated
		so that users can see when they've updated ego.conf but forgotten to run ego sync to update their meta-repo.

		I would also like to display the time it was last synced and the timestamp of when the tree was updated
		remotely.
		"""
		self.echo(color.green(self.config.meta_repo_root) + ":")
		if not os.path.exists(self.config.meta_repo_root):
			self.log(" meta-repo does not exist and needs to be cloned.")
		else:
			self.log("")
		for kit in self.kit_info["kit_order"]:
			kit_branch, kit_default_branch = self.get_selected_kit(kit, True)
			if kit_branch == kit_default_branch or kit_branch is None:
				self.log("  " + kit.ljust(20) + " " + color.BLUE + kit_default_branch + color.END)
			else:
				self.log("  " + kit.ljust(20) + " " + color.CYAN + kit_branch + color.END + " (default %s)" % (
					kit_default_branch if kit_default_branch else "(None)"))

	def handle(self, **options):
		if options['status']:
			self.meta_repo_info(**options)
		else:
			self.sync_meta_repo(**options)

# vim: ts=4 sw=4 noet
