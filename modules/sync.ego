#!/usr/bin/python3

import os
import pwd
import re
import sys
from ego import EgoModule
from ego_helpers import Color, run_ego_module, ago
from git_helper import GitHelper
from cmdtools import run
from datetime import datetime

class Module(EgoModule):

	hex_re = re.compile('[0-9a-fA-F]+')

	@property
	def root(self):
		if not hasattr(self, '_root'):
			root = self.config.meta_repo_root
			if not os.path.exists(os.path.dirname(root)):
				os.makedirs(os.path.dirname(root))
			self._root = root
		return self._root

	def add_arguments(self, parser):
		parser.add_argument('--kits-only', action='store_true', help="Do not sync meta-repo, only kits.")
		parser.add_argument('--status', action='store_true', help="Display selected kit branches.")

	def sync_kit(self, kit_name, branch=None):
		if branch is None:
			# use default
			branch = self.kit_info["kit_settings"][kit_name]["default"]
		if branch is None:
			self.fatal("Fatal: branch cannot be None.")
		if branch == self.kit_info["kit_settings"][kit_name]["default"]:
			self.log(Color.purple("Syncing %s branch %s" % (kit_name, branch)))
		else:
			# highlight non-default branches in green for convenience
			self.log(Color.purple("Syncing %s branch " % kit_name) + Color.green(branch) + Color.purple(" (non-default)"))
		kit_path = os.path.join(self.config.kit_root, kit_name)
		kit = GitHelper(self, kit_path)
		if not kit.isGitRepo():
			try:
				os.rmdir(kit.root)
			except OSError:
				pass
		if not kit.exists():
			retval = kit.shallowClone(self.config.sync_base_url.format(repo=kit_name), branch, depth=2)
			if retval != 0:
				self.fatal("Could not clone kit '%s' into '%s'." % (kit_name, kit_path))

		if not kit.localBranchExists(branch):
			kit.fetchRemote(branch)
		kit.checkout(branch)
		kit.reset(options=["--hard"])
		kit.clean(options=["-fd"])
		kit.pull(options=["-f", "--no-commit"])

		# do sync
		sha1 = kit.commitID
		desired_sha1 = self.kit_sha1[kit_name][branch]
		success = False

		def sha1_check(sha1, desired_sha1):
			self.debug((sha1, desired_sha1))
			if not self.hex_re.match(sha1):
				self.fatal("Fatal: kit CommitID not a SHA1: %s" % sha1)
			if not self.hex_re.match(desired_sha1):
				self.fatal("Fatal: kit-sha1.json value not a SHA1: %s" % desired_sha1)

		sha1_check(sha1, desired_sha1)

		if sha1 == desired_sha1:
			success = True
		else:
			kit.fetchRemote(branch)
			sha1 = kit.commitID
			sha1_check(sha1, desired_sha1)
			if sha1 != desired_sha1:
				success = kit.checkout(desired_sha1)
		return success

	def sync_meta_repo(self, **options):
		pwnam = pwd.getpwnam(self.config.sync_user)
		uid = pwnam.pw_uid
		gid = pwnam.pw_gid
		if "HOME" in os.environ:
			# git will look here for various things
			del os.environ["HOME"]
		if not os.path.exists(self.root):
			try:
				os.mkdir(self.root)
			except PermissionError:
				self.fatal(
					"You don't have enough privileges. You should probably run this command as root."
				)
		stat_info = os.stat(self.root)
		if stat_info.st_uid != uid and self.config.sync_user != "root":
			try:
				run("chown -R %s:%s %s" % (uid, gid, self.root), quiet=True)
			except PermissionError:
				self.fatal(
					"You don't have enough privileges. You should probably run this command as root."
				)
		# We need to fork here in order to sync as sync_user and then switch back to root
		pid = os.fork()
		if pid == 0:
			try:
				os.setgid(gid)
				os.setuid(uid)
			except PermissionError:
				self.fatal(
					"You don't have enough privileges. You should probably run this command as root."
				)
			if not options['kits_only']:
				repo = GitHelper(self, self.root)
				self.log(Color.green("Syncing meta-repo"))
				if repo.isGitRepo():
					retval = repo.fetchRemote("master")
					retval = repo.pull(options=["--no-commit", "-f", "--no-recurse-submodules"])
					if retval != 0:
						self.fatal("There was an error syncing meta-repo.")
				else:
					retval = repo.shallowClone(
						self.config.sync_base_url.format(repo="meta-repo"), self.config.meta_repo_branch)
					if retval != 0:
						self.fatal("Could not clone meta-repo into '%s'." % (self.root,))
			fails = []
			for kt in self.kit_info["kit_order"]:
				branch = None
				if "kits" in self.config.settings:
					if kt in self.config.settings["kits"]:
						branch = self.config.settings["kits"][kt]

				# Let's now check to make sure that the kit specified in settings is a valid kit, still present in
				# metadata. If not, we should inform the user and fall back to the default kit.

				if branch != None:
					if branch not in self.kit_sha1[kt]:
						# We are not recording a sha1 -- this is not an active kit
						self.warning("Kit %s branch %s specified in ego.conf is not currently active; using default kit instead." % (kt, branch))
						branch = None

				success = self.sync_kit(kt, branch=branch)
				if not success:
					fails.append((kt, branch))
			if len(fails):
				for kt, branch in fails:
					self.error("There was an error syncing %s." % kt)
				sys.exit(1)
			sys.exit(0)
		# Forked process terminated here
		if os.waitpid(pid, 0)[1] > 0:
			return False
		self.log(Color.green("Sync successful and kits in alignment! :)"))
		self.log(Color.green("Updating profiles..."))
		try:
			run_ego_module(self.install_path, 'profile', self.config, ['update'])
		except PermissionError:
			self.error("Could not update ego profiles automatically due to permissions (code in /root, most likely.)")
			self.error("Please run epro update manually as root.")
		return True

	def meta_repo_info(self, **options):
		"""
		This implements 'ego sync status' and is just a starting point. It currently displays the ego.conf-defined
		or default repo, but not the actual git repo that is selected on disk. So it should be a lot more sophisticated
		so that users can see when they've updated ego.conf but forgotten to run ego sync to update their meta-repo.

		I would also like to display the time it was last synced and the timestamp of when the tree was updated
		remotely.
		"""

		if not os.path.exists(self.config.meta_repo_root):
			print("meta-repo does not exist and needs to be cloned.")
			return
		repo = GitHelper(self, self.root)
		sync_ago_string = ago(datetime.now() - repo.last_sync())
		print(Color.green(self.config.meta_repo_root) + " (updated %s):" % sync_ago_string)
		print("  " + Color.UNDERLINE + "kit".ljust(20), "branch".ljust(20), "default".ljust(20), "stability".ljust(9) + Color.END)
		for kit in self.kit_info["kit_order"]:
			kit_branch, kit_default_branch = self.get_selected_kit(kit, True)
			if kit_branch == None:
				kit_branch = kit_default_branch
			if 'stability' in self.kit_info["kit_settings"][kit] and kit_branch in \
					self.kit_info['kit_settings'][kit]['stability']:
				kit_stability = self.kit_info["kit_settings"][kit]['stability'][kit_branch]
				if kit_stability == "prime":
					kit_stability = Color.green("prime")
				elif kit_stability == "near-prime":
					kit_stability = Color.blue("near-prime")
				elif kit_stability == "beta":
					kit_stability = Color.yellow("beta")
				elif kit_stability in [ "alpha", "dev", "current" ]:
					kit_stability = Color.red(kit_stability)
			else:
				kit_stability = ""
			if kit_branch == kit_default_branch:
				print("  " + kit.ljust(20), Color.BLUE + kit_default_branch.ljust(20), "(same)".ljust(20), str(kit_stability).ljust(10) + Color.END)
			else:
				kb_out = kit_default_branch if kit_default_branch else "(None)"
				print("  " + kit.ljust(20), Color.CYAN + kit_branch.ljust(20), kb_out.ljust(20), str(kit_stability).ljust(10) + Color.END)

	def handle(self, **options):
		if options['status']:
			self.meta_repo_info(**options)
		else:
			self.sync_meta_repo(**options)

# vim: ts=4 sw=4 noet
